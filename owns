#!/usr/bin/env ruby
#
# owns
#
# Copyright (c) 2013 fauno <fauno@endefensadelsl.org>
#
# See AUTHORS for a list of contributors
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation; either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General
# Public License along with this program.  If not, see
# <http://www.gnu.org/licenses/>.

# Eventually we want to migrate this to lua or something smaller for
# embedded services.
# 
# TODO test for error, owns.yml sanity, etc.


require 'yaml'
require 'mustache'
require 'open3'
require 'net/https'

@cur_dir = File.dirname(__FILE__)

class Zone < Mustache
  self.template_path = "#{File.dirname(__FILE__)}/templates"
end

class Nsd < Mustache
  self.template_path = "#{File.dirname(__FILE__)}/templates"
end

def run_process(line, message)
  puts message
  Open3::popen3(line) do |stdin, stdout, stderr|
    puts 'Output:'
    puts stdout.read.strip

    puts 'Errors:'
    puts stderr.read.strip
  end
end

def get_public_address(service)
  Net::HTTP.get(URI(service || 'http://ns2.librevpn.org.ar'))
end

# Load data
owns_data = YAML.load_file("#{@cur_dir}/owns.yml")

puts 'Generating nsd.conf...'
File.open("#{@cur_dir}/nsd.conf", 'w') { |nsd_conf|
  nsd_conf.rewind
  nsd_conf.write(Nsd.render(owns_data))
}

# Create the zone directory
puts 'Creating zones directory...'
FileUtils.mkdir_p('zones')

# Lingering zone files can trick nsd into believing we still serve
# them...
puts 'Removing old zones...'
FileUtils.rm(Dir.glob('zones/*.zone'))

# Obtain public address if the field was left empty
owns_data['public_address'] = get_public_address(owns_data['public_address_service']) if owns_data['public_address'].nil?

# Traverse all zones
owns_data['zones'].each do |zone_data|
# Merge with the general configuration, zone-specific info takes
# precedence
  zone_data = owns_data.merge(zone_data)

# If this zone is delegated to us, don't create a zone file so the
# transfer is forced
  next if not zone_data['authorities'].nil?

# Generate a serial from the current time
  zone_data['serial'] = Time.new.to_i if zone_data['serial'].nil?

# Inform what we're doing
  puts "Generating #{zone_data['zone']} with serial #{zone_data['serial']}..."

# Write the zonefile!
  File.open("zones/#{zone_data['zone']}.zone", 'w') { |zone_file|
    zone_file.rewind
    zone_file.write(Zone.render(zone_data))
  }

end

run_process("nsd-checkconf #{@cur_dir}/nsd.conf", 'Checking configuration...')

if owns_data['nsd4']
  # If we're using nsd4, we need the keys for nsd-control
  run_process('nsd-control-setup',  'NSD control setup') unless File.exists?("#{@cur_dir}/nsd_control.key")
  run_process('nsd-control reload', 'Reloading zones...')
  run_process('nsd-control notify', 'Notifying delegates...')
else # nsd3
  run_process('nsdc rebuild', 'Rebuilding zones...')
  run_process('nsdc stop',    'Stopping nsd...')
  run_process('nsdc start',   'Starting nsd...')
  run_process('nsdc notify',  'Notifying delegates...')
end
